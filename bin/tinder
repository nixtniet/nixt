#!/usr/bin/env python3
# This file is placed in the Public Domain.


import importlib.util
import os
import queue
import shutil
import sys
import threading
import time


sys.path.insert(0, os.getcwd())


from nixt.defines import Config, Message, Output, Workdir
from nixt.defines import command, elapsed, fmt, launch, moddir, parse
from nixt.defines import scan, skel, spl


Config.debug = True
Config.level = "info"
Config.name = "rssbot"
Config.version = 658
Workdir.wdr = ".test"


events = queue.Queue()


class CLI(Output):

    def __init__(self):
        Output.__init__(self)
        self.register("command", command)

    def raw(self, txt):
        if "v" in Config.opts:
            print(txt)


class Pool:

    clients = []
    lock = threading.RLock()
    nrcpu = 1
    nrlast = 0

    @staticmethod
    def add(client):
        Pool.clients.append(client)

    @staticmethod
    def init(clz, nr):
        Pool.nrcpu = nr
        for _x in range(Pool.nrcpu):
            clt = clz()
            clt.start()
            Pool.add(clt)

    @staticmethod
    def put(event):
        with Pool.lock:
            if Pool.nrlast >= Pool.nrcpu-1:
                Pool.nrlast = 0
            clt = Pool.clients[Pool.nrlast]
            clt.put(event)
            Pool.nrlast += 1


class Mods:

    dirs = {}
    modules = {}


def adddir(name, path):
    "add module directory."
    Mods.dirs[name] = path


def addpkg(*pkgs):
    "register package directory."
    for pkg in pkgs:
        adddir(pkg.__name__, pkg.__path__[0])


def configure():
    if os.path.exists("examples"):
        adddir("mods", "examples")
        return
    if os.path.exists("mods"):
        adddir("mods", "mods")
        return
    path = os.path.expanduser(f"~/.local/share/pipx/venvs/{Config.name}/share/{Config.name}/examples/")
    if os.path.exists(path):
        adddir(f"{Config.name}.modules", path)
        return
    path = moddir()
    if os.path.exists(path):
        adddir("modules", path)


def getmod(name):
    "import module by name." 
    if name in Mods.modules:
        return Mods.modules[name]
    mname = ""
    pth = ""
    for packname, path in Mods.dirs.items():
        modpath = os.path.join(path, name + ".py")
        if os.path.exists(modpath):
            pth = modpath
            mname = f"{packname}.{name}"
            break
    return importer(mname, pth)


def importer(name, pth=""):
    "import module by path."
    if pth and os.path.exists(pth):
        spec = importlib.util.spec_from_file_location(name, pth)
    else:
        spec = importlib.util.find_spec(name)
    if not spec or not spec.loader:
        return None
    mod = importlib.util.module_from_spec(spec)
    if not mod:
        return None
    Mods.modules[name] = mod
    spec.loader.exec_module(mod)
    return mod


def pkgdir(name):
    return f".local/share/pipx/venvs/{name}/share/{name}/examples"


def mods(names):
    "list of named modules."
    return [getmod(x) for x in sorted(spl(names))]


def modules():
    "comma seperated list of available modules."
    mods = []
    for name, path in Mods.dirs.items():
        if not os.path.exists(path):
            continue
        mods.extend([
            x[:-3] for x in os.listdir(path)
            if x.endswith(".py") and not x.startswith("__")
        ])
    return ",".join(sorted(mods))


def scanner(names=None):
    "scan named modules for commands."
    if names is None:
        names = modules()
    mods = []
    for name in spl(names):
        module = getmod(name)
        if not module:
            continue
        scan(module)
    return mods


"runtime"


def banner(name, version):
    tme = time.ctime(time.time()).replace("  ", " ")
    print(f"{name.upper()} {version} since {tme} ({Config.level})")
    sys.stdout.flush()


def check(text):
    args = sys.argv[1:]
    for arg in args:
        if not arg.startswith("-"):
            continue
        for char in text:
            if char in arg:
                return True
    return False


def consume():
    while True:
        try:
            event = events.get()
            event.wait()
            events.task_done()
        except (KeyboardInterrupt, EOFError):
            os._exit(0)


def payload(todo):
    for cmd, example in todo.items():
        for ex in example:
            evt = Message()
            evt.text = f"{cmd} {ex}"
            evt.kind = "command"
            Pool.put(evt)
            events.put(evt)


examples = {
    "atr": [""],
    "cmd": [""],
    "dis": [""],
    "dne": ["", "bla"],
    "dpl": ["hnrss title,url", ""],
    "eml": ["", "root@localhost"],
    "flt": ["", "0"],
    "fnd": ["", "log", "rss", "config", "todo"],
    "lou": [""],
    "man": ["", "test"],
    "mbx": [""],
    "mod": [""],
    "mre": [""],
    "nme": ["", "hnrss hackernews"],
    "now": [""],
    "pth": [""],
    "pwd": ["", "bla mekker"],
    "req": [""],
    "res": ["", "hnrss"],
    "sil": [""],
    "slg": [""],
    "srv": [""],
    "syn": [""],
    "thr": [""],
    "tmr": ["", "22:00 test"],
    "upt": [""],
    "ver": [""],
    "wsd": [""]
}

pre = {
    "cfg": ["", "nick=mekker"],
    "imp": ["", "tests/feeds.opml"],
    "log": ["", "log add"],
    "rss": ["", "http://hnrss.org/newest"],
    "tdo": ["", "test"]
}

post = {
    "dbg": [""],
    "dne": ["", "mekker"],
    "exp": [""],
    "rem": ["", "hnrss"]
}



def main():
    if os.path.exists(Workdir.wdr):
        shutil.rmtree(Workdir.wdr)
    skel()
    parse(Config, " ".join(sys.argv[1:]))
    configure()
    scanner()
    if "v" in Config.opts:
        banner(Config.name, Config.version)
    if "z" in Config.opts:
        Pool.init(CLI, os.cpu_count())
    else:
        Pool.init(CLI, 1)
    starttime = time.time()
    thrs = []
    nrs = Config.index or 1
    for _x in range(nrs):
        thrs.append(launch(payload, pre))
    for thr in thrs:
        thr.join()
    for _x in range(nrs):
        thrs.append(launch(payload, examples))
    for thr in thrs:
        thr.join()
    for _x in range(nrs):
        thrs.append(launch(payload, post))
    for thr in thrs:
        thr.join()
    launch(consume)
    nrevents = events.qsize()
    try:
        events.join()
    except (KeyboardInterrupt, EOFError):
        os._exit(0)
    endtime = time.time()
    lap = elapsed(endtime-starttime)
    percall = (endtime-starttime)/nrevents
    nrs = events.qsize()
    if "v" in Config.opts:
        print(f"{fmt(Config)}")
        print(f"{nrs} events left.")
        print(f"total: {lap} nrs: {nrevents} call: %.6fs" % percall)
    os._exit(0)


if __name__ == "__main__":
    main()
