#!/usr/bin/env python3
# This file is placed in the Public Domain.


import logging
import os
import sys
import threading
import time


sys.path.insert(0, os.getcwd())


from nixt.command import Commands
from nixt.clients import CLI
from nixt.configs import Config
from nixt.kernels import Kernel
from nixt.message import Message
from nixt.statics import SYSTEMD
from nixt.threads import threadhook
from nixt.utility import forever, privileges, spl, wrapped
from nixt.workdir import pidfile, pidname


"config"


Config.ignore = "wsd,udp"
Config.name = "nixt" 
Config.version = 440


TXT = " ".join(sys.argv[1:])


"clients"


class CLI(CLI):

    def raw(self, text):
        print(text.encode('utf-8', 'replace').decode("utf-8"))


class Console(CLI):

    def callback(self, event):
        if not event.text:
            return
        super().callback(event)
        event.wait()

    def poll(self):
        evt = Message()
        evt.text = input("> ")
        evt.kind = "command"
        return evt


"scripts"


def background():
    daemon(check("v"))
    Kernel.boot(TXT)
    Commands.add(cmd, ver)
    pidfile(pidname(Config.name))
    Kernel.forever()


def console():
    import readline # noqa: F401
    Kernel.boot(TXT, sys.stdout)
    Commands.add(cmd, ver)
    csl = Console()
    csl.start()
    Kernel.forever()


def control():
    if len(sys.argv) == 1:
        return
    Kernel.boot(TXT)
    Commands.add(cmd, srv, ver)
    csl = CLI()
    csl.silent = False
    evt = Message()
    evt.orig = repr(csl)
    evt.text = " ".join(sys.argv[1:])
    evt.type = "command"
    Commands.command(evt)
    evt.wait()


def service():
    Kernel.boot()
    Commands.add(cmd, ver)
    pidfile(pidname(Config.name))
    Kernel.forever()


"utility"


def banner():
    tme = time.ctime(time.time()).replace("  ", " ")
    logger = logging.getLogger()
    print("%s %s since %s (%s)" % (
                                   Config.name.upper(),
                                   Config.version,
                                   tme,
                                   logging.getLevelName(logger.getEffectiveLevel())
                                  ))
    sys.stdout.flush()


def check(text):
    args = sys.argv[1:]
    for arg in args:
        if not arg.startswith("-"):
            continue
        for char in text:
            if char in arg:
                return True
    return False


def daemon(verbose=False):
    pid = os.fork()
    if pid != 0:
        os._exit(0)
    os.setsid()
    pid2 = os.fork()
    if pid2 != 0:
        os._exit(0)
    if not verbose:
        with open('/dev/null', 'r', encoding="utf-8") as sis:
            os.dup2(sis.fileno(), sys.stdin.fileno())
        with open('/dev/null', 'a+', encoding="utf-8") as sos:
            os.dup2(sos.fileno(), sys.stdout.fileno())
        with open('/dev/null', 'a+', encoding="utf-8") as ses:
            os.dup2(ses.fileno(), sys.stderr.fileno())
    os.umask(0)
    os.chdir("/")
    os.nice(10)


def wrap(func):
    import termios
    old = None
    try:
        old = termios.tcgetattr(sys.stdin.fileno())
    except termios.error:
        pass
    try:
        wrapped(func)
    finally:
        if old:
            termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, old)


"commands"


def cmd(event):
    event.reply(",".join(sorted(Commands.names or Commands.cmds)))


def srv(event):
    import getpass
    name = getpass.getuser()
    event.reply(SYSTEMD % (Config.name.upper(), name, name, name, Config.name))


def ver(event):
    event.reply(f"{Config.name.upper()} {Config.version}")


"runtime"


def main():
    Kernel.configure(" ".join(sys.argv[1:]))
    if check("b"):
        threading.excepthook = threadhook
    if check('z'):
        Config.debug = True
    if check("c"):
        wrap(console)
    elif check("d"):
        background()
    elif check("s"):
        wrapped(service)
    else:
        wrapped(control)


if __name__ == "__main__":
    main()
