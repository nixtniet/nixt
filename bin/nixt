#!/usr/bin/env python3
# This file is placed in the Public Domain.


"main program"


import argparse
import logging
import os
import sys
import time


sys.path.insert(0, os.getcwd())


from nixt.command import Commands, Main
from nixt.clients import Console
from nixt.message import Message
from nixt.package import Mods
from nixt.utility import Utils
from nixt.persist import Workdir
from nixt.utility import Log


from nixt import modules as MODS


"config"


Main.debug = False
Main.ignore = "rst,udp,web"
Main.level = "info"
Main.local = True
Main.name = Utils.pkgname(Commands)
Main.txt = " ".join(sys.argv[1:])
Main.version = 8
Main.wdr = os.path.expanduser(f"~/.{Main.name}")


"clients"


class Line(Console):

    def __init__(self):
        super().__init__()
        self.register("command", Commands.command)

    def raw(self, text):
        "write to console."
        Runtime.out(text)


class CSL(Line):

    def callback(self, event):
        "wait for callback result."
        if not event.text:
            event.ready()
            return
        super().callback(event)
        event.wait()

    def poll(self):
        "poll for an event."
        evt = Message()
        evt.text = input("> ")
        evt.kind = "command"
        return evt


"scripts"


class Scripts:

    @staticmethod
    def background(args):
        "background script."
        Runtime.daemon()
        Runtime.privileges()
        Runtime.boot(args)
        Workdir.pidfile(Main.name)
        Mods.scanner(Mods.list(), Main.ignore)
        Commands.add(Cmd.cmd, Cmd.mod, Cmd.ver)
        Mods.inits(Main.default or "irc,mdl,rss,wsd", Main.ignore)
        Runtime.forever()

    @staticmethod
    def console(args):
        "console script."
        import readline
        readline.redisplay()
        Runtime.boot(args)
        Mods.scanner(Mods.list(), Main.ignore)
        Commands.add(Cmd.cmd, Cmd.mod, Cmd.ver)
        Commands.cmd(Main.txt)
        Mods.inits(Main.mods, Main.ignore, Main.wait)
        csl = CSL()
        csl.start()
        Runtime.forever()

    @staticmethod
    def control(args):
        "cli script."
        if len(sys.argv) == 1:
            return
        Runtime.boot(args)
        Mods.scanner(Mods.list(), Main.ignore)
        Commands.add(Cmd.cmd, Cmd.mod, Cmd.srv, Cmd.ver)
        evt = Commands.cmd(Main.txt)
        for line in evt.result.values():
            Runtime.out(line)

    @staticmethod
    def service(args):
        "service script."
        Runtime.privileges()
        Runtime.banner()
        Runtime.boot(args)
        Workdir.pidfile(Main.name)
        Mods.scanner(Mods.list())
        Commands.add(Cmd.cmd, Cmd.mod, Cmd.ver)
        Mods.inits(Main.default or "irc,mdl,rss,wsd", Main.ignore)
        Runtime.forever()


"commands"


class Cmd:

    @staticmethod
    def cmd(event):
        "list available commands."
        event.reply(",".join(sorted(Commands.names or Commands.cmds)))

    @staticmethod
    def mod(event):
        "list available commands."
        mods = Mods.list(Main.ignore)
        if not mods:
            event.reply("no modules available")
            return
        event.reply(mods)

    @staticmethod
    def srv(event):
        "generate systemd service file."
        import getpass
        name = getpass.getuser()
        event.reply(SYSTEMD % (Main.name.upper(), name, name, name, Main.name))

    @staticmethod
    def ver(event):
        "show verson."
        event.reply(f"{Main.name.upper()} {Main.version}")


"runtime"


class Runtime:
    
    @staticmethod
    def banner():
        "hello."
        tme = time.ctime(time.time()).replace("  ", " ")
        print("%s %s since %s (%s)" % (
            Main.name.upper(),
            Main.version,
            tme,
            Main.level.upper(),
        ))
        sys.stdout.flush()

    @staticmethod
    def boot(args):
        "in the beginning."
        Main.all     = args.all or Main.all
        Main.level   = args.level or Main.level
        Main.local   = args.local or Main.local
        Main.mods    = args.mods or Main.mods
        Main.txt     = args.txt
        Main.verbose = args.verbose or Main.verbose
        Main.wait    = args.wait or Main.wait
        Main.wdr     = args.wdr or Main.wdr or os.path.expanduser(f"~/.{Utils.pkgname(Main)}")
        Workdir.setwd(Main.wdr)
        Log.level(Main.level)
        if Main.wdr:
            Mods.init("modules", os.path.join(Workdir.workdir(), "mods"))
        if MODS:
            Mods.init(MODS.__name__, MODS.__path__[0])
        if Main.local:
            Mods.init('mods', 'mods')
        if Main.verbose:
            Runtime.banner()
        if Main.all:
            Main.mods = Mods.list(Main.ignore)

    @staticmethod
    def daemon(verbose=False, nochdir=False):
        "run in the background."
        pid = os.fork()
        if pid != 0:
            os._exit(0)
        os.setsid()
        pid2 = os.fork()
        if pid2 != 0:
            os._exit(0)
        with open('/dev/null', 'r', encoding="utf-8") as sis:
            os.dup2(sis.fileno(), sys.stdin.fileno())
        with open('/dev/null', 'a+', encoding="utf-8") as sos:
            os.dup2(sos.fileno(), sys.stdout.fileno())
        with open('/dev/null', 'a+', encoding="utf-8") as ses:
            os.dup2(ses.fileno(), sys.stderr.fileno())
        os.umask(0)
        os.chdir("/")
        os.nice(10)

    @staticmethod
    def forever():
        "run forever until ctrl-c."
        while True:
            try:
                time.sleep(0.1)
            except (KeyboardInterrupt, EOFError):
                break

    @staticmethod
    def getargs():
        "parse commandline arguments."
        parser = argparse.ArgumentParser(description=f"{Main.name.upper()}")
        parser.add_argument("-a", "--all", action="store_true", help="load all modules")
        parser.add_argument("-c", "--console", action="store_true", help="start console")
        parser.add_argument("-d", "--daemon", action="store_true", help="start background daemon")
        parser.add_argument("-l", "--level", default=Main.level, help='set loglevel')
        parser.add_argument("-m", "--mods", default="", help='modules to load')
        parser.add_argument("-s", "--service", action="store_true", help="start service")
        parser.add_argument("-v", "--verbose", action='store_true',help='enable verbose')
        parser.add_argument("-w", "--wait", action='store_true',help='wait for services to start')
        parser.add_argument("--local", action="store_true", help="use local mods directory")
        parser.add_argument("--wdr", help='set working directory')
        return parser.parse_known_args()

    @staticmethod
    def out(txt):
        print(txt.encode('utf-8', 'replace').decode("utf-8"))

    @staticmethod
    def privileges():
        "drop privileges."
        import getpass
        import pwd
        pwnam2 = pwd.getpwnam(getpass.getuser())
        os.setgid(pwnam2.pw_gid)
        os.setuid(pwnam2.pw_uid)

    @staticmethod
    def wrap(func, *args):
        "restore console."
        import termios
        old = None
        try:
            old = termios.tcgetattr(sys.stdin.fileno())
        except termios.error:
            pass
        try:
            func(*args)
        except (KeyboardInterrupt, EOFError):
            pass
        except Exception as ex:
            logging.exception(ex)
        if old:
            termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, old)


"data"


SYSTEMD = """[Unit]
Description=%s
After=multi-user.target

[Service]
Type=simple
User=%s
Group=%s
ExecStart=/home/%s/.local/bin/%s -s

[Install]
WantedBy=multi-user.target"""


"runtime"


def main():
    "main"
    args, arguments = Runtime.getargs()
    args.txt = " ".join(arguments)
    if args.daemon:
        Scripts.background(args)
    elif args.console:
        Runtime.wrap(Scripts.console, args)
    elif args.service:
        Runtime.wrap(Scripts.service, args)
    else:
        Runtime.wrap(Scripts.control, args)
    Mods.shutdown()


if __name__ == "__main__":
    main()
