#!/usr/bin/env python3
# This file is placed in the Public Domain.


"main"


import json
import logging
import os
import os.path
import pathlib
import signal
import sys
import time


sys.path.insert(0, os.getcwd())


from nixt.clients import Client, Fleet
from nixt.command import Commands
from nixt.kernels import Kernel, Main
from nixt.persist import Workdir
from nixt.runtime import Event, Logging


Kernel.ignore = ["wsd", "rst", "udp", "web"]


checksum = "1d97ac137d929cf07f8992b0ec78cfd8"


def handler(signum, frame):
    print("handler called!")


signal.signal(signal.SIGHUP, handler)


class CLI(Client):

    def __init__(self):
        Client.__init__(self)
        self.register("command", Commands.command)

    def raw(self, txt):
        print(txt.encode('utf-8', 'replace').decode("utf-8"))


class Console(CLI):

    def announce(self, txt):
        pass

    def callback(self, event):
        super().callback(event)
        event.wait()

    def poll(self):
        evt = Event()
        evt.txt = input("> ")
        evt.type = "command"
        return evt


class Scripts:


    @staticmethod
    def pidfile(filename):
        if os.path.exists(filename):
            os.unlink(filename)
        path2 = pathlib.Path(filename)
        path2.parent.mkdir(parents=True, exist_ok=True)
        with open(filename, "w", encoding="utf-8") as fds:
            fds.write(str(os.getpid()))

    @staticmethod
    def privileges():
        import getpass
        import pwd
        pwnam2 = pwd.getpwnam(getpass.getuser())
        os.setgid(pwnam2.pw_gid)
        os.setuid(pwnam2.pw_uid)

    @staticmethod
    def background():
        Kernel.daemon("-v" in sys.argv)
        Kernel.privileges()
        Main.level = Main.sets.get("level", Main.level or "warn")
        Logging.level(Main.level or "debug")
        Workdir.setwd(Main.name)
        Kernel.pidfile(Workdir.pidname(Main.name))
        Kernel.sums(checksum)
        Commands.table()
        Commands.add(cmd)
        Commands.add(ver)
        Kernel.inits(Main.init or "irc,rss")
        Kernel.forever()

    @staticmethod
    def console():
        import readline # noqa: F401
        Commands.parse(Main, " ".join(sys.argv[1:]))
        Main.init = Main.sets.get("init", Main.init)
        Main.verbose = Main.sets.get("verbose", Main.verbose)
        Main.level   = Main.sets.get("level", Main.level or "warn")
        Logging.level(Main.level)
        Workdir.setwd(Main.name)
        Kernel.banner()
        Kernel.sums(checksum)
        Commands.table()
        Commands.add(cmd)
        Commands.add(ver)
        for _mod, thr in Kernel.inits(Main.init):
            if "w" in Main.opts:
                thr.join(30.0)
        csl = Console()
        csl.start(daemon=True)
        Kernel.forever()

    @staticmethod
    def control():
        if len(sys.argv) == 1:
            return
        Commands.parse(Main, " ".join(sys.argv[1:]))
        Logging.level(Main.level or "warn")
        Workdir.setwd(Main.name)
        Kernel.sums(checksum)
        Commands.table()
        Commands.add(cmd)
        Commands.add(md5)
        Commands.add(srv)
        Commands.add(tbl)
        Commands.add(ver)
        csl = CLI()
        evt = Event()
        evt.orig = repr(csl)
        evt.type = "command"
        evt.txt = Main.otxt
        Commands.command(evt)
        evt.wait()

    @staticmethod
    def service():
        Logging.level(Main.level or "warn")
        Workdir.setwd(Main.name)
        Kernel.banner()
        Kernel.privileges()
        Kernel.pidfile(Workdir.pidname(Main.name))
        Kernel.sums(checksum)
        Commands.table()
        Commands.add(cmd)
        Commands.add(ver)
        Kernel.inits(Main.init or "irc,rss")
        Kernel.forever()

class Mainer:

    @staticmethod
    def check(txt):
        args = sys.argv[1:]
        for arg in args:
            if not arg.startswith("-"):
                continue
            for char in txt:
                if char in arg:
                    return True
        return False

    @staticmethod
    def wrapped(func):
        try:
            func()
        except (KeyboardInterrupt, EOFError):
            print("")
        Fleet.shutdown()

    @staticmethod
    def wrap(func):
        import termios
        old = None
        try:
            old = termios.tcgetattr(sys.stdin.fileno())
        except termios.error:
            pass
        try:
            Mainer.wrapped(func)
        finally:
            if old:
                termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, old)

    @staticmethod
    def main():
        if Mainer.check("a"):
            Main.init = ",".join(Kernel.modules())
        if Mainer.check("v"):
            Main.opts["v"] = True
        if Mainer.check("c"):
            Mainer.wrap(Scripts.console)
        elif Mainer.check("d"):
            Scripts.background()
        elif Mainer.check("s"):
            Mainer.wrapped(Scripts.service)
        else:
            Mainer.wrapped(Scripts.control)


def cmd(event):
    event.reply(",".join(sorted(Commands.names)))


def md5(event):
    tbl = Kernel.mods("tbl")[0]
    event.reply(Kernel.md5sum(tbl.__file__))


def srv(event):
    import getpass
    name = getpass.getuser()
    event.reply(TXT % (Main.name.upper(), name, name, name, Main.name))


def tbl(event):
    if not check("f"):
        Commands.names = {}
    for module in Kernel.mods():
        Commands.scan(module)
    event.reply("# This file is placed in the Public Domain.")
    event.reply("")
    event.reply("")
    event.reply('"lookup tables"')
    event.reply("")
    event.reply("")
    event.reply(f"NAMES = {json.dumps(Commands.names, indent=4, sort_keys=True)}")
    event.reply("")
    event.reply("")
    event.reply("MD5 = {")
    for module in Kernel.mods():
        event.reply(f'    "{module.__name__.split(".")[-1]}": "{Kernel.md5sum(module.__file__)}",')
    event.reply("}")


def ver(event):
    event.reply(str(Main.version))


TXT = """[Unit]
Description=%s
After=network-online.target

[Service]
Type=simple
User=%s
Group=%s
ExecStart=/home/%s/.local/bin/%s -s

[Install]
WantedBy=multi-user.target"""


if __name__ == "__main__":
    Mainer.main()
