#!/usr/bin/env python3
# This file is placed in the Public Domain.


"main"


import json
import os
import os.path
import sys


sys.path.insert(0, os.getcwd())


from nixt.clients import Client, Fleet
from nixt.command import Commands
from nixt.kernels import Kernel, Main
from nixt.persist import Workdir
from nixt.runtime import Event, Logging


Kernel.checksum = "1d97ac137d929cf07f8992b0ec78cfd8"
Kernel.ignore = ["wsd", "rst", "udp", "web"]


class CLI(Client):

    def __init__(self):
        Client.__init__(self)
        self.register("command", Commands.command)

    def raw(self, txt):
        print(txt.encode('utf-8', 'replace').decode("utf-8"))


class Console(CLI):

    def announce(self, txt):
        pass

    def callback(self, event):
        super().callback(event)
        event.wait()

    def poll(self):
        evt = Event()
        evt.txt = input("> ")
        evt.type = "command"
        return evt


class Scripts:

    @staticmethod
    def background():
        Kernel.daemon("-v" in sys.argv)
        Kernel.privileges()
        Main.level = Main.sets.get("level", Main.level or "warn")
        Logging.level(Main.level or "debug")
        Workdir.setwd(Main.name)
        Kernel.pidfile(Workdir.pidname(Main.name))
        Kernel.sums()
        Commands.table()
        Commands.add(Cmds.ver)
        Kernel.inits(Main.init or "irc,rss")
        Kernel.forever()

    @staticmethod
    def console():
        import readline # noqa: F401
        Commands.parse(Main, " ".join(sys.argv[1:]))
        Main.init = Main.sets.get("init", Main.init)
        Main.verbose = Main.sets.get("verbose", Main.verbose)
        Main.level   = Main.sets.get("level", Main.level or "warn")
        Logging.level(Main.level)
        Workdir.setwd(Main.name)
        Kernel.banner()
        Kernel.sums()
        Commands.table()
        Commands.add(Cmds.ver)
        for _mod, thr in Kernel.inits(Main.init):
            if "w" in Main.opts:
                thr.join(30.0)
        csl = Console()
        csl.start(daemon=True)
        Kernel.forever()

    @staticmethod
    def control():
        if len(sys.argv) == 1:
            return
        Commands.parse(Main, " ".join(sys.argv[1:]))
        Logging.level(Main.level or "warn")
        Workdir.setwd(Main.name)
        Kernel.sums()
        Commands.table()
        Commands.add(Cmds.md5)
        Commands.add(Cmds.srv)
        Commands.add(Cmds.tbl)
        Commands.add(Cmds.ver)
        csl = CLI()
        evt = Event()
        evt.orig = repr(csl)
        evt.type = "command"
        evt.txt = Main.otxt
        Commands.command(evt)
        evt.wait()

    @staticmethod
    def service():
        Logging.level(Main.level or "warn")
        Workdir.setwd(Main.name)
        Kernel.banner()
        Kernel.privileges()
        Kernel.pidfile(Workdir.pidname(Main.name))
        Kernel.sums()
        Commands.table()
        Commands.add(Cmds.ver)
        Kernel.inits(Main.init or "irc,rss")
        Kernel.forever()


class Cmds:

    @staticmethod
    def cmd(event):
        event.reply(",".join(sorted(Commands.names)))

    @staticmethod
    def md5(event):
        tbl = Kernel.mods("tbl")[0]
        event.reply(Kernel.md5sum(tbl.__file__))

    @staticmethod
    def srv(event):
        import getpass
        name = getpass.getuser()
        event.reply(TXT % (Main.name.upper(), name, name, name, Main.name))

    @staticmethod
    def tbl(event):
        if not Mainer.check("f"):
            Commands.names = {}
        for module in Kernel.mods():
            Commands.scan(module)
        event.reply("# This file is placed in the Public Domain.")
        event.reply("")
        event.reply("")
        event.reply('"lookup tables"')
        event.reply("")
        event.reply("")
        event.reply(f"NAMES = {json.dumps(Commands.names, indent=4, sort_keys=True)}")
        event.reply("")
        event.reply("")
        event.reply("MD5 = {")
        for module in Kernel.mods():
            event.reply(f'    "{module.__name__.split(".")[-1]}": "{Kernel.md5sum(module.__file__)}",')
        event.reply("}")

    @staticmethod
    def ver(event):
        event.reply(str(Main.version))


class Run:

    @staticmethod
    def check(txt):
        args = sys.argv[1:]
        for arg in args:
            if not arg.startswith("-"):
                continue
            for char in txt:
                if char in arg:
                    return True
        return False

    @staticmethod
    def wrapped(func):
        try:
            func()
        except (KeyboardInterrupt, EOFError):
            print("")
        Fleet.shutdown()

    @staticmethod
    def wrap(func):
        import termios
        old = None
        try:
            old = termios.tcgetattr(sys.stdin.fileno())
        except termios.error:
            pass
        try:
            Run.wrapped(func)
        finally:
            if old:
                termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, old)

    @staticmethod
    def main():
        if Run.check("a"):
            Main.init = ",".join(Kernel.modules())
        if Run.check("v"):
            Main.opts["v"] = True
        if Run.check("c"):
            Run.wrap(Scripts.console)
        elif Run.check("d"):
            Scripts.background()
        elif Run.check("s"):
            Run.wrapped(Scripts.service)
        else:
            Run.wrapped(Scripts.control)

TXT = """[Unit]
Description=%s
After=network-online.target

[Service]
Type=simple
User=%s
Group=%s
ExecStart=/home/%s/.local/bin/%s -s

[Install]
WantedBy=multi-user.target"""


if __name__ == "__main__":
    Run.main()
