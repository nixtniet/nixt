#!/usr/bin/env python3
# This file is placed in the Public Domain.


"main program"


import os
import sys
import threading
import time


sys.path.insert(0, os.getcwd())


from nixt.clients import Client
from nixt.command import Commands, addcmd, command, scanner
from nixt.configs import Cfg
from nixt.loggers import level
from nixt.message import Message
from nixt.methods import parse
from nixt.package import Mods, adddir, init, modules
from nixt.serials import dumps
from nixt.utility import forever, where, wrapped
from nixt.workdir import Workdir, moddir, pidfile, pidname, skel


"defines"


TXT = " ".join(sys.argv[1:])


"config"


Cfg.ignore = "udp"
Cfg.level = "info"
Cfg.name = "nixt" 
Cfg.version = 453


"clients"


class Line(Client):

    def __init__(self):
        super().__init__()
        self.register("command", command)

    def raw(self, text):
        "write to console."
        print(text.encode('utf-8', 'replace').decode("utf-8"))


class Console(Line):

    def __init__(self):
        super().__init__()
        self.done = threading.Event()
        self.done.set()

    def callback(self, event):
        "wait for callback result."
        if not event.text:
            event.ready()
            self.done.set()
            return
        super().callback(event)
        event.wait()
        self.done.set()

    def poll(self):
        "poll for an event."
        self.done.wait()
        self.done.clear()
        evt = Message()
        evt.text = input("> ")
        evt.kind = "command"
        return evt

    def raw(self, txt):
        "add newline if waiting."
        if not self.done.is_set():
            super().raw(txt)


"utility"


def banner():
    "hello."
    tme = time.ctime(time.time()).replace("  ", " ")
    print("%s %s %s since %s (%s)" % (
        Cfg.name.upper(),
        Cfg.version,
        Cfg.opts.strip().upper(),
        tme,
        Cfg.level.upper() or 'INFO'
    ))
    sys.stdout.flush()


def boot(cfg):
    "in the beginning."
    Workdir.wdr = Workdir.wdr or os.path.expanduser(f"~/.{cfg.name}")
    skel()
    parse(cfg, TXT)
    level(cfg.sets.level or "info")
    adddir(f"{Cfg.name}.modules", os.path.join(where(Message), "modules"))
    if check("n"):
        adddir(f"{Cfg.name}.network", os.path.join(where(Message), "network"))
    adddir("modules", moddir())
    if os.path.exists('examples'):
        adddir("modz", "examples")
    if check("m"):
        if os.path.exists('mods'):
            adddir("mods", "mods")


def check(text):
    "check for options."
    for arg in TXT.split():
        if not arg.startswith("-"):
            continue
        for char in text:
               if char in arg:
                   return True
        return False

 
def daemon(verbose=False, nochdir=False):
    "run in the background."
    pid = os.fork()
    if pid != 0:
        os._exit(0)
    os.setsid()
    pid2 = os.fork()
    if pid2 != 0:
        os._exit(0)
    with open('/dev/null', 'r', encoding="utf-8") as sis:
        os.dup2(sis.fileno(), sys.stdin.fileno())
    with open('/dev/null', 'a+', encoding="utf-8") as sos:
        os.dup2(sos.fileno(), sys.stdout.fileno())
    with open('/dev/null', 'a+', encoding="utf-8") as ses:
        os.dup2(ses.fileno(), sys.stderr.fileno())
    os.umask(0)
    os.chdir("/")
    os.nice(10)


def privileges():
    "drop privileges."
    import getpass
    import pwd
    pwnam2 = pwd.getpwnam(getpass.getuser())
    os.setgid(pwnam2.pw_gid)
    os.setuid(pwnam2.pw_uid)


def wrap(func):
    "restore console."
    import termios
    old = None
    try:
        old = termios.tcgetattr(sys.stdin.fileno())
    except termios.error:
        pass
    try:
        wrapped(func)
    finally:
        pass
    if old:
        termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, old)


"scripts"


def background():
    "background script."
    daemon()
    privileges()
    boot(Cfg)
    pidfile(pidname(Cfg.name))
    addcmd(cmd, mod, ver)
    scanner(modules(Cfg.ignore))
    init(modules(Cfg.ignore))
    forever()


def console():
    "console script."
    import readline
    readline.redisplay()
    boot(Cfg)
    if check('v'):
        banner()
    scanner(modules(Cfg.ignore))
    addcmd(cmd, mod, ver)
    mds = Cfg.sets.init
    if not mds and check('a'):
        mds = modules(Cfg.ignore)
    init(mds, check("w"))
    csl = Console()
    csl.start()
    forever()


def control():
    "cli script."
    if len(sys.argv) == 1:
        return
    boot(Cfg)
    if check('t'):
        Commands.names = {}
    if not Commands.names:
        scanner(modules(Cfg.ignore))
    if check("t"):
        print(dumps(Commands.names, indent=4))
    addcmd(cmd, mod, srv, ver)
    cli = Line()
    evt = Message()
    evt.orig = repr(cli)
    evt.text = " ".join(sys.argv[1:])
    evt.type = "command"
    command(evt)
    evt.wait()


def service():
    "service script."
    privileges()
    boot(Cfg)
    banner()
    pidfile(pidname(Cfg.name))
    addcmd(cmd, mod, ver)
    scanner(modules(Cfg.ignore))
    init(modules(Cfg.ignore))
    forever()


"commands"


def cmd(event):
    "list available commands."
    event.reply(",".join(sorted(Commands.names or Commands.cmds)))


def mod(event):
    "list available commands."
    event.reply(modules())


def srv(event):
    "generate systemd service file."
    import getpass
    name = getpass.getuser()
    event.reply(SYSTEMD % (Cfg.name.upper(), name, name, name, Cfg.name))


def ver(event):
    "show version."
    event.reply(f"{Cfg.name.upper()} {Cfg.version} {Cfg.opts.upper()}")


"data"


SYSTEMD = """[Unit]
Description=%s
After=multi-user.target

[Service]
Type=simple
User=%s
Group=%s
ExecStart=/home/%s/.local/bin/%s -s

[Install]
WantedBy=multi-user.target"""


Commands.names = {
    "atr": "atr",
    "flt": "flt",
    "fnd": "fnd",
    "cfg": "irc",
    "mre": "irc",
    "pwd": "irc",
    "log": "log",
    "lst": "lst",
    "dpl": "rss",
    "exp": "rss",
    "imp": "rss",
    "nme": "rss",
    "rem": "rss",
    "res": "rss",
    "rss": "rss",
    "syn": "rss",
    "lou": "sil",
    "sil": "sil",
    "dne": "tdo",
    "tdo": "tdo",
    "thr": "thr",
    "tmr": "tmr",
    "upt": "upt"
}


"runtime"


def main():
    "main"
    if check("d"):
        background()
    elif check("c"):
        wrap(console)
    elif check("s"):
        wrapped(service)
    else:
        wrapped(control)


if __name__ == "__main__":
    main()
