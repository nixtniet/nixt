#!/usr/bin/env python3
# This file is placed in the Public Domain.


"main program"


import importlib.util
import inspect
import os
import sys
import threading
import time


sys.path.insert(0, os.getcwd())


from nixt.brokers import getobj
from nixt.clients import Client
from nixt.loggers import level
from nixt.message import Message
from nixt.methods import parse
from nixt.objects import Default
from nixt.serials import dumps
from nixt.threads import launch
from nixt.utility import forever, spl, where, wrapped


if os.path.exists("mods"):
    import mods as MODS
else:
    MODS = None


"defines"


DEBUG = False
INIT = "irc,rss"
LEVEL = "info"
NAME = "nixt"
TXT = " ".join(sys.argv[1:])
VERSION = 453


Cfg = Default()


"clients"


class Line(Client):

    def __init__(self):
        super().__init__()
        self.register("command", command)

    def raw(self, text):
        "write to console."
        print(text.encode('utf-8', 'replace').decode("utf-8"))


class Console(Line):

    def __init__(self):
        super().__init__()
        self.done = threading.Event()
        self.done.set()

    def callback(self, event):
        "wait for callback result."
        if not event.text:
            event.ready()
            self.done.set()
            return
        super().callback(event)
        event.wait()
        self.done.set()

    def poll(self):
        "poll for an event."
        self.done.wait()
        self.done.clear()
        evt = Message()
        evt.text = input("> ")
        evt.kind = "command"
        return evt

    def raw(self, txt):
        "add newline if waiting."
        if not self.done.is_set():
            super().raw(txt)


"commands"


class Commands:

    cmds = {}
    names = {}


def addcmd(*args):
    "add functions to commands."
    for func in args:
        name = func.__name__
        Commands.cmds[name] = func
        Commands.names[name] = func.__module__.split(".")[-1]


def command(evt):
    "command callback."
    parse(evt, evt.text)
    func = getcmd(evt.cmd)
    if func:
        func(evt)
        bot = getobj(evt.orig)
        bot.display(evt)
    evt.ready()


def getcmd(cmd):
    "get function for command."
    func =  Commands.cmds.get(cmd, None)
    if func:
        return func
    name = Commands.names.get(cmd, None)
    if name:
        mod = getmod(name)
        if mod:
            scancmd(mod)
    return Commands.cmds.get(cmd, None)
        

def importer(name, pth=""):
    "import module by path."
    if pth and os.path.exists(pth):
        spec = importlib.util.spec_from_file_location(name, pth)
    else:
        spec = importlib.util.find_spec(name)
    if not spec or not spec.loader:
        return None
    mod = importlib.util.module_from_spec(spec)
    if not mod:
        return None
    spec.loader.exec_module(mod)
    mod.DEBUG = DEBUG
    mod.NAME = NAME
    return mod


def scancmd(module):
    "scan a module for functions with event as argument."
    for key, cmdz in inspect.getmembers(module, inspect.isfunction):
        if 'event' not in inspect.signature(cmdz).parameters:
            continue
        addcmd(cmdz)


def scanner(*pkgs, inits=""):
    "scan named modules for commands."
    mods = []
    for pkg in pkgs:
        if not pkg:
            continue
        path = pkg.__path__[0]
        for fnm in os.listdir(path):
            if fnm.startswith("__"):
                continue
            name = fnm[:-3]
            modname = f"{pkg.__name__}.{name}"
            mod = importer(modname, os.path.join(path, fnm))
            if not mod:
                continue
            scancmd(mod)
            if name not in inits:
                continue
            if "init" not in dir(mod):
                continue
            launch(mod.init)
    return mods


"utility"


def banner():
    "hello."
    tme = time.ctime(time.time()).replace("  ", " ")
    print("%s %s since %s (%s)" % (
        NAME.upper(),
        VERSION,
        tme,
        LEVEL.upper() or 'INFO'
    ))
    sys.stdout.flush()


def check(text):
    "check for options."
    for arg in TXT.split():
        if not arg.startswith("-"):
            continue
        for char in text:
               if char in arg:
                   return True
        return False

 
def daemon(verbose=False, nochdir=False):
    "run in the background."
    pid = os.fork()
    if pid != 0:
        os._exit(0)
    os.setsid()
    pid2 = os.fork()
    if pid2 != 0:
        os._exit(0)
    with open('/dev/null', 'r', encoding="utf-8") as sis:
        os.dup2(sis.fileno(), sys.stdin.fileno())
    with open('/dev/null', 'a+', encoding="utf-8") as sos:
        os.dup2(sos.fileno(), sys.stdout.fileno())
    with open('/dev/null', 'a+', encoding="utf-8") as ses:
        os.dup2(ses.fileno(), sys.stderr.fileno())
    os.umask(0)
    os.chdir("/")
    os.nice(10)


def privileges():
    "drop privileges."
    import getpass
    import pwd
    pwnam2 = pwd.getpwnam(getpass.getuser())
    os.setgid(pwnam2.pw_gid)
    os.setuid(pwnam2.pw_uid)


def wrap(func):
    "restore console."
    import termios
    old = None
    try:
        old = termios.tcgetattr(sys.stdin.fileno())
    except termios.error:
        pass
    try:
        wrapped(func)
    finally:
        pass
    if old:
        termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, old)


"scripts"


def background():
    "background script."
    daemon()
    privileges()
    pidfile(pidname(NAME))
    addcmd(cmd, mod, ver)
    level(LEVEL)
    scanner(MODS, inits="irc,rss")
    init(MODS)
    forever()


def console():
    "console script."
    import readline
    readline.redisplay()
    if check('v'):
        banner()
    level(LEVEL)
    scanner(MODS, inits=INIT)
    addcmd(cmd, mod, ver)
    csl = Console()
    csl.start()
    forever()


def control():
    "cli script."
    if len(sys.argv) == 1:
        return
    level(LEVEL)
    scanner(MODS)
    addcmd(cmd, mod, ver)
    cli = Line()
    evt = Message()
    evt.orig = repr(cli)
    evt.text = " ".join(sys.argv[1:])
    evt.type = "command"
    command(evt)
    evt.wait()


def service():
    "service script."
    privileges()
    banner()
    pidfile(pidname(NAME))
    addcmd(cmd, mod, ver)
    level(LEVEL)
    scanner(MODS, inits=INIT)
    forever()


"commands"


def cmd(event):
    "list available commands."
    event.reply(",".join(sorted(Commands.names or Commands.cmds)))


def mod(event):
    "list available commands."
    event.reply(modules())


def ver(event):
    "show version."
    event.reply(f"{NAME.upper()} {VERSION}")


"runtime"


def main():
    "main"
    if check("d"):
        background()
    elif check("c"):
        wrap(console)
    elif check("s"):
        wrapped(service)
    else:
        wrapped(control)


if __name__ == "__main__":
    main()
