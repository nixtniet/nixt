#!/usr/bin/env python3
# This file is placed in the Public Domain.


"main program"


import os
import pathlib
import sys
import time


sys.path.insert(0, os.getcwd())


from nixt.clients import CLI
from nixt.command import Commands, command, enable
from nixt.configs import Config
from nixt.loggers import level
from nixt.message import Message
from nixt.methods import parse
from nixt.package import adddir, getmod, modules, scanner
from nixt.statics import SYSTEMD
from nixt.threads import launch
from nixt.utility import spl, wrapped
from nixt.workdir import Workdir, moddir, pidfile, skel


"config"


Config.ignore = ""
Config.level = "info"
Config.name = "nixt" 
Config.opts = ""
Config.txt = " ".join(sys.argv[1:])
Config.version = 453


"clients"


class Line(CLI):

    def raw(self, text):
        "write to console."
        print(text.encode('utf-8', 'replace').decode("utf-8"))


class Console(Line):

    def callback(self, event):
        "wait for callback result."
        if not event.text:
            return
        super().callback(event)
        event.wait()

    def poll(self):
        "poll for inpput."
        evt = Message()
        evt.text = input("> ")
        evt.kind = "command"
        return evt


"scripts"


def background():
    "background script."
    daemon(check("v"), check("m"))
    privileges()
    boot(Config)
    pidfile(pidname(Config.name))
    enable(cmd, mod, ver)
    scanner(modules())
    init(modules())
    forever()


def console():
    "console script."
    import readline
    readline.redisplay()
    boot(Config)
    if "v" in Config.opts:
        banner()
    scanner()
    enable(cmd, drs, mod, ver)
    if "a" in Config.opts:
        mds = modules()
    else:
        mds = Config.sets.init
    init(mds, "w" in Config.opts)
    csl = Console()
    csl.start()
    forever()


def control():
    "cli script."
    if len(sys.argv) == 1:
        return
    boot(Config)
    scanner()
    enable(cmd, drs, mod, srv, ver)
    cli = Line()
    evt = Message()
    evt.orig = repr(cli)
    evt.text = " ".join(sys.argv[1:])
    evt.type = "command"
    command(evt)
    evt.wait()


def service():
    "service script."
    privileges()
    boot(Config)
    banner()
    pidfile(pidname(Config.name))
    enable(cmd, mod, ver)
    scanner()
    init(modules())
    forever()


"utility"


def banner():
    "hello"
    tme = time.ctime(time.time()).replace("  ", " ")
    print("%s %s %s since %s (%s)" % (
        Config.name.upper(),
        Config.version,
        Config.opts.strip().upper(),
        tme,
        Config.level.upper()
    ))
    sys.stdout.flush()


def boot(cfg):
    "in the beginning."
    Workdir.wdr = Workdir.wdr or os.path.expanduser(f"~/.{cfg.name}")
    skel()
    parse(cfg, cfg.txt)
    level(cfg.sets.level or cfg.level or "info")
    adddir("modules", moddir())


def check(text):
    "check for options."
    args = sys.argv[1:]
    for arg in args:
        if not arg.startswith("-"):
            continue
        for char in text:
               if char in arg:
                   return True
        return False


def daemon(verbose=False, nochdir=False):
    "run in the background."
    pid = os.fork()
    if pid != 0:
        os._exit(0)
    os.setsid()
    pid2 = os.fork()
    if pid2 != 0:
        os._exit(0)
    if not verbose:
        with open('/dev/null', 'r', encoding="utf-8") as sis:
            os.dup2(sis.fileno(), sys.stdin.fileno())
        with open('/dev/null', 'a+', encoding="utf-8") as sos:
            os.dup2(sos.fileno(), sys.stdout.fileno())
        with open('/dev/null', 'a+', encoding="utf-8") as ses:
            os.dup2(ses.fileno(), sys.stderr.fileno())
    if not nochdir:
        os.umask(0)
        os.chdir("/")
    os.nice(10)


def forever():
    "run forever until ctrl-c."
    while True:
        try:
            time.sleep(0.1)
        except (KeyboardInterrupt, EOFError):
            break


def init(names=None, wait=False):
    "run init function of modules."
    if names is None:
        names = modules()
    mods = []
    for name in spl(names):
        module = getmod(name)
        if not module:
            continue
        if "init" in dir(module):
            thr = launch(module.init)
            mods.append((module, thr))
    if wait:
        for module, thr in mods:
            thr.join()
    return mods


def privileges():
    "drop privileges."
    import getpass
    import pwd
    pwnam2 = pwd.getpwnam(getpass.getuser())
    os.setgid(pwnam2.pw_gid)
    os.setuid(pwnam2.pw_uid)


def wrap(func):
    "restore console."
    import termios
    old = None
    try:
        old = termios.tcgetattr(sys.stdin.fileno())
    except termios.error:
        pass
    try:
        wrapped(func)
    finally:
        pass
    if old:
        termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, old)


"commands"


def cmd(event):
    "list available commands."
    event.reply(",".join(sorted(Commands.names or Commands.cmds)))


def mod(event):
    "list available commands."
    event.reply(modules())


def srv(event):
    "generate systemd service file."
    import getpass
    name = getpass.getuser()
    event.reply(SYSTEMD % (Config.name.upper(), name, name, name, Config.name))


def ver(event):
    "show version."
    event.reply(f"{Config.name.upper()} {Config.version} {Config.opts}")


"main"


def main():
    "runtime."
    if check('z'):
        Config.debug = True
    if check("c"):
        wrap(console)
    elif check("d"):
        background()
    elif check("s"):
        wrapped(service)
    else:
        wrapped(control)


if __name__ == "__main__":
    main()
