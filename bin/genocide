#!/usr/bin/env python3
# This file is placed in the Public Domain.


"""| **Information and Evidence Unit**
| **Office of the Prosecutor**
| **Post Office Box 19519**
| **2500 CM The Hague**
| **The Netherlands**
|


Hello Office of the Prosecutor, 

i write you in the context of communications and claims under art.15 of
the Rome Statute. i want to inform the prosecutor that the king of the
netherlands and his government are commiting 3 of the 5 crimes defined
in the Rome Statute.

The dutch government has introduced three new forced care laws, the Wfz
(wet forensische zorg) for criminals, the WvGGZ (Wet verplichte GGZ) for
the disturbed and addicted and the Wzd (Wet zorg en dwang) for the
handicapped.

Both the chamber suggesting these laws to the king and the king himself
have been informed about the fact the the substances administered under
these laws are proven to be poison (1).

There is proof the medication used in forced treatments in the
netherlands are poison.

1) haloperidol

https://echa.europa.eu/substance-information/-/substanceinfo/100.000.142

2) clozapine

https://echa.europa.eu/substance-information/-/substanceinfo/100.024.831

3) olanzapine

https://echa.europa.eu/substance-information/-/substanceinfo/100.125.320

4) aripriprazole

https://echa.europa.eu/substance-information/-/substanceinfo/100.112.532


With the mass scale torture with poison the king of the netherlands and
his chamber:

(1) kills
(2) does grave bodily and mental harm
(3) makes impotent

on the following victim groups here in the Netherlands:

(1) verslaafden (addicts)
(2) bejaarden (elderly)
(3) ggz patienten (psychiatric patients)
(4) criminelen (criminials)
(5) gehandicapten (handicapped)

Since the members of the chamber and the king were aware that these
medicine are poison at the time they voted for this law and the day the
Wfz law took effect (1-1-2019), i ask the prosecutor to prosecute the
king for making the commiting of the above mentioned crimes (killing,
torture and impotent making) possible.
"""


import inspect
import os
import sys
import time
import threading


sys.path.insert(0, os.getcwd())


from nixt.client  import Client
from nixt.fleet   import Fleet
from nixt.object  import Object
from nixt.thread  import hook


sys.excepthook = hook


a = os.path.abspath
d = os.path.dirname
p = os.path.join


class Default(Object):

    def __getattr__(self, key):
        if key not in self:
            setattr(self, key, "")
        return self.__dict__.get(key, "")


class Main(Default):

    debug   = False
    gets    = Default()
    ignore  = ""
    init    = ""
    level   = "warn"
    md5     = True
    name    = "genocide"
    opts    = Default()
    otxt    = ""
    sets    = Default()
    verbose = False
    version = 340


class Event(Object):

    def __init__(self):
        Object.__init__(self)
        self._ready  = threading.Event()
        self._thr    = None
        self.channel = ""
        self.ctime   = time.time()
        self.orig    = ""
        self.rest    = ""
        self.result  = {}
        self.type    = "event"
        self.txt     = ""

    def done(self):
        self.reply("ok")

    def ready(self):
        self._ready.set()

    def reply(self, txt):
        self.result[time.time()] = txt

    def wait(self, timeout=None):
        self._ready.wait()
        if self._thr:
            self._thr.join()

class Commands:

    cmds  = {}
    md5   = {}
    names = {}

    @staticmethod
    def add(func, mod=None):
        Commands.cmds[func.__name__] = func
        if mod:
            Commands.names[func.__name__] = mod.__name__.split(".")[-1]

    @staticmethod
    def get(cmd):
        return Commands.cmds.get(cmd, None)

    @staticmethod
    def scan(mod):
        for key, cmdz in inspect.getmembers(mod, inspect.isfunction):
            if key.startswith("cb"):
                continue
            if 'event' in cmdz.__code__.co_varnames:
                Commands.add(cmdz, mod)


class CLI(Client):

    def __init__(self):
        Client.__init__(self)
        self.register("command", command)

    def raw(self, txt):
        print(txt.encode('utf-8', 'replace').decode("utf-8"))
        sys.stdout.flush()


"utilities"


def command(evt):
    parse(evt)
    func = Commands.get(evt.cmd)
    if not func:
        evt.ready()
        return
    func(evt)
    Fleet.display(evt)
    evt.ready()


def parse(obj, txt=""):
    if txt == "":
        if "txt" in dir(obj):
            txt = obj.txt
        else:
            txt = ""
    args = []
    obj.args   = []
    obj.cmd    = ""
    obj.gets   = Default()
    obj.index  = None
    obj.mod    = ""
    obj.opts   = ""
    obj.result = {}
    obj.sets   = Default()
    obj.silent = Default()
    obj.txt    = txt
    obj.otxt   = obj.txt
    _nr = -1
    for spli in obj.otxt.split():
        if spli.startswith("-"):
            try:
                obj.index = int(spli[1:])
            except ValueError:
                obj.opts += spli[1:]
            continue
        if "-=" in spli:
            key, value = spli.split("-=", maxsplit=1)
            setattr(obj.silent, key, value)
            setattr(obj.gets, key, value)
            continue
        if "==" in spli:
            key, value = spli.split("==", maxsplit=1)
            setattr(obj.gets, key, value)
            continue
        if "=" in spli:
            key, value = spli.split("=", maxsplit=1)
            if key == "mod":
                if obj.mod:
                    obj.mod += f",{value}"
                else:
                    obj.mod = value
                continue
            setattr(obj.sets, key, value)
            continue
        _nr += 1
        if _nr == 0:
            obj.cmd = spli
            continue
        args.append(spli)
    if args:
        obj.args = args
        obj.txt  = obj.cmd or ""
        obj.rest = " ".join(obj.args)
        obj.txt  = obj.cmd + " " + obj.rest
    else:
        obj.txt = obj.cmd or ""


"commands"


def cmd(event):
    event.reply(",".join(sorted([x for x in Commands.cmds])))


def pth(event):
    PATH = p(d(d(__file__)), "html", "index.html")
    event.reply(f"file://localhost{PATH}")


def req(event):
    event.reply(__doc__)


def slg(event):
    TXT = "By law using poison, castrated, tortured, killed, destructed in whole or in part since 4 March 2019. @intlcrimcourt reconsider OTP-CR-117/19 http://bit.ly/gcid3"
    event.reply(TXT)


"main"


def main():
    if len(sys.argv) == 1:
        return
    parse(Main, " ".join(sys.argv[1:]))
    Commands.add(cmd)
    Commands.add(pth)
    Commands.add(slg)
    Commands.add(req)
    csl = CLI()
    evt = Event()
    evt.orig = repr(csl)
    evt.type = "command"
    evt.txt = Main.otxt
    command(evt)
    evt.wait()


if __name__ == "__main__":
    main()


